팩토리 메서드 패턴
-
- 객체 생성처리를 서브클래스로 분리하여 처리하도록 하는 캡슐화 패턴
- 객체 생성을 별도 클래스, 메서드로 분리하여 객체 생성의 변화에 대비하는데 유용
- 특정기능의 구현은 개별 클래스를 통해 제공되는 것이 바람직
  - 기능의 변경이나 상황에 따른 기능의 선택은 해당 객체를 생성하는 코드의 변경을 초래한다.
  - 상황에 따라 적절한 객체를 생성하는 코드는 자주 중복될 수 있음
  - 객체 생성방식의 변화는 해당되는 모든 코드 부분을 변경해야하는 문제가 발생할 수 있다.
- 스트래티지 패턴, 싱글톤패턴, 템플릿 메서드 패턴을 활용한다.

예제 문제점 1
- 엘레베이터의 작업처리량 최대화 전략이 아닌 사용자의 대기시간을 최대화하는 전략을 선택한 경우
- 런타임 도중에 시간에 따라 전략을 변경하는 경우

스트래티지 패턴으로 문제를 해결한 경우 시간에 따라 적절한 전략을 선택할 수 있고 ElevatorManager 입장에서는
여러 전략이 있기때문에 ElevatorScheduler 인터페이스를 이용하여 여러 전략을 캡슐화하여 동적으로 선택가능
하지만 문제점은 여전히 남아있는데, 

예제 문제점2

스트래티지 패턴으로 스케쥴링 전략이 추가되거나
- ResponseTimeSchduler, ThroughputScheduler 등 

동적방식으로 전략을 선택하도록 변경되면
- if() { scheduler = new ...() }

해당 스케쥴링 전략을 지원하는 구체적인 클래스를 생성하고, ElevatorManager의 requestElevator메서드도 수정할 수 밖에 없음

* requestElevator메서드 책임은 엘레베이터 선택과 이동만 가지고 있다.

즉, 만약 새로운 전략이 추가 되어야한다거나 동적 전략 선택방식의 알고리즘에 수정이 생긴다면,
requestElevator메서드에 변경이 생기기 때문에 이는 바람직한 설계가 아니다.

해결방안
1. 주어진 기능을 제공하는 클래스 생성작업을 별도의 클래스/메서드로 분리
    - SchedulerFactory클래스 생성
2. 동적스케쥴링 방식이면 여러 번 객체를 생성하지않고, 한번 생성한 것을 재사용하는 것이 바람직 -> 싱글톤 패턴을 활용
    - 생성자를 통해 객체를 생성하지 않음 -> public -> private, getInstance라는 정적메서드로 객체를 생성
